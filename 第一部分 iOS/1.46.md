# Hybrid 设计与实现

随着移动浪潮的兴起，各种 App 层出不穷，极速发展的业务拓展提升了团队对开发效率的要求，这个时候纯粹使用 Native 开发技术成本难免会更高一点。而 H5 的低成本、高效率、跨平台等特性马上被利用起来了，形成一种新的开发模式： Hybrid App

作为一种混合开发的模式，Hybrid App 底层依赖于 Native 提供的容器（Webview），上层使用各种前端技术完成业务开发（现在三足鼎立的 Vue、React、Angular），底层透明化、上层多样化。这种场景非常有利于前端介入，非常适合业务的快速迭代。于是 Hybrid 火了。

大道理谁都懂，但是按照我知道的情况，还是有非常多的人和公司在 Hybrid 这一块并没有做的很好，所以我将我的经验做一个总结，希望可以帮助广大开发者的技术选型有所帮助


## Hybrid 的一个现状

可能早期都是 PC 端的网页开发，随着移动互联网的发展，iOS、Android 智能手机的普及，非常多的业务和场景都从 PC 端转移到移动端。开始有前端开发者为移动端开发网页。这样子早期资源打包到 Native App 中会造成应用包体积的增大。越来越多的业务开始用 H5 尝试，这样子难免会需要一个需要访问 Native 功能的地方，这样子可能早期就是懂点前端技术的 Native 开发者自己封装或者暴露 Native 能力给 JS 端，等业务较多的时候者样子很明显不现实，就需要专门的 Hybrid 团队做这个事情；量大了，就需要规矩，就需要规范。

总结：
1. Hybrid 开发效率高、跨平台、低成本
2. Hybrid 从业务上讲，没有版本问题，有 Bug 可以及时修复

Hybrid 在大量应用的时候就需要一定的规范，那么本文将讨论一个 Hybrid 的设计知识。
 - Hybrid 、Native、前端各自的工作是什么
 - Hybrid 交互接口如何设计
 - Hybrid 的 Header 如何设计
 - Hybrid 的如何设计目录结构以及增量机制如何实现
 - 资源缓存策略，白屏问题...


## Native 与前端分工
在做 Hybird 架构设计之前我们需要分清 Native 与前端的界限。首先 Native 提供的是宿主环境，要合理利用 Native 提供的能力，要实现通用的 Hybrid 架构，站在大前端的视觉，我觉得需要考虑以下核心设计问题。

### 交互设计

Hybrid 架构设计的第一要考虑的问题就是如何设计前端与 Native 的交互，如果这块设计不好会对后续的开发、前端框架的维护造成深远影响。并且这种影响是不可逆、积重难返。所以前期需要前端与 Native 好好配合、提供通用的接口。比如

1. Native UI 组件、Header 组件、消息类组件
2. 通讯录、系统、设备信息读取接口
3. H5 与 Native 的互相跳转。比如 H5 如何跳转到一个 Native 页面，H5 如何新开 Webview 并做动画跳转到另一个 H5 页面

### 账号信息设计

账号系统是重要且无法避免的，Native 需要设计良好安全的身份验证机制，保证这块对业务开发者足够透明，打通账户体系

### Hybrid 开发调试

功能设计、编码完并不是真正结束，Native 与前端需要商量出一套可开发调试的模型，不然很多业务开发的工作难以继续。

[iOS调试技巧](https://www.jianshu.com/p/f430caa81fa8)

Android 调试技巧：
1. App 中开启 Webview 调试(WebView.setWebContentsDebuggingEnabled(true);　)
2. chrome 浏览器输入 chrome://inspect/#devices 访问可以调试的 webview 列表
3. 需要翻墙的环境


![结构](./../assets/HybridStructure.jpg)



## Hybrid 交互设计

Hybrid 交互无非是 Native 调用 H5 页面JS 方法，或者 H5 页面通过 JS 调 Native 提供的接口。2者通信的桥梁是 Webview。
业界主流的通信方法：1.桥接对象（时机问题，不太主张这种方式）；2.自定义 Url scheme

![通信原理](./../assets/)

App 自身定义了 url scheme，将自定义的 url 注册到调度中心，例如
weixin:// 可以打开微信。

关于 Url scheme 如果不太清楚可以看看 [这篇文章](https://www.jianshu.com/p/253479ccc83a)

### JS to Native

Native 在每个版本都会提供一些 Api，前端会有一个对应的框架团队对其封装，释放业务接口。举例

```
SDGHybrid.http.get()  // 向业务服务器拿数据
SDGHybrid.http.post() // 向业务服务器提交数据
SDGHybrid.http.sign() // 计算签名
SDGHybrid.http.getUA()  // 获取UserAgent
```

```
SDGHybridReady(function(arg){
  SDGHybrid.http.post({
    url: arg.baseurl + '/feedback',
    params:{
      title: '点菜很慢',
      content: '服务差'
    },
    success: (data) => {
      renderUI(data);
    },
    fail: (err) => {
      console.log(err);
    }
  })
})
```

前端框架定义了一个全局变量 SDGHybrid 作为 Native 与前端交互的桥梁，前端可以通过这个对象获得访问 Native 的能力


### Api 交互

调用 Native Api 接口的方式和使用传统的 Ajax 调用服务器，或者 Native 的网络请求提供的接口相似
![Api交互](./../assets/HybridApi.jpg)

所以我们需要封装的就是模拟创建一个类似 Ajax 模型的 Native 请求。

![通信示例](./../assets/Hybrid-Ajax.jpg)


### 格式约定
交互的第一步是设计数据格式。这里分为请求数据格式与响应数据格式，参考 Ajax 模型：

```
$.ajax({
  type: "GET",
  url: "test.json",
  data: {username:$("#username").val(), content:$("#content").val()},
  dataType: "json",
  success: function(data){
    renderUI(data);           
  }
});
```
```
$.ajax(options) => XMLHTTPRequest
type(默认值：GET)，HTTP请求方法（GET|POST|DELETE|...）
url(默认值：当前url)，请求的url地址
data(默认值：'') 请求中的数据如果是字符串则不变，如果为Object，则需要转换为String，含有中文则会encodeURI
```

所以 Hybrid 中的请求模型为：
```
requestHybrid({
  // H5 请求由 Native 完成
  tagname: 'NativeRequest',
  // 请求参数
  param: requestObject,
  // 结果的回调
  callback: function (data) {
    renderUI(data);
  }
});
```
这个方法会形成一个 URL，比如：
SDGHybrid://NativeRequest?t=1545840397616&callback=Hybrid_1545840397616&param=%7B%22url%22%3A%22https%3A%2F%2Fwww.datacubr.com%2FApi%2FSearchInfo%2FgetLawsInfo%22%2C%22params%22%3A%7B%22key%22%3A%22%22%2C%22page%22%3A1%2C%22encryption%22%3A1%7D%2C%22Hybrid_Request_Method%22%3A0%7D

Native 的 webview 环境可以监控内部任何的资源请求，判断如果是 SDGHybrid 则分发事件，处理结束可能会携带参数，参数需要先 urldecode 然后将结果数据通过 Webview 获取 window 对象中的 callback（Hybrid_时间戳）

数据返回的格式和普通的接口返回格式类似
```
{
  errno: 1,
  message: 'App版本过低，请升级App版本',
  data: {}
}
```
这里注意：真实数据在 data 节点中。如果 errno 不为0，则需要提示 message。


简易版本代码实现。

```
//通用的 Hybrid call Native
window.SDGbrHybrid = window.SDGbrHybrid || {};
var loadURL = function (url) {
	var iframe = document.createElement('iframe');
	iframe.style.display = "none";
	iframe.style.width = '1px';
	iframe.style.height = '1px';
	iframe.src = url;
	document.body.appendChild(iframe);
	setTimeout(function () {
		iframe.remove();
	}, 100);
};

var _getHybridUrl = function (params) {
	var paramStr = '', url = 'SDGHybrid://';
	url += params.tagname + "?t=" + new Date().getTime();
	if (params.callback) {
		url += "&callback=" + params.callback;
		delete params.callback;
	}

	if (params.param) {
		paramStr = typeof params.param == "object" ? JSON.stringify(params.param) : params.param;
		url += "&param=" + encodeURIComponent(paramStr);
	}
	return url;
};


var requestHybrid = function (params) {
	//生成随机函数
	var tt = (new Date().getTime());
	var t = "Hybrid_" + tt;
	var tmpFn;

	if (params.callback) {
		tmpFn = params.callback;
		params.callback = t;
		window.SDGHybrid[t] = function (data) {
			tmpFn(data);
			delete window.SDGHybrid[t];
		}
	}
	loadURL(_getHybridUrl(params));
};

//获取版本信息，约定APP的navigator.userAgent版本包含版本信息：scheme/xx.xx.xx
var getHybridInfo = function () {
    var platform_version = {};
    var na = navigator.userAgent;
    var info = na.match(/scheme\/\d\.\d\.\d/);
 
    if (info && info[0]) {
      info = info[0].split('/');
      if (info && info.length == 2) {
        platform_version.platform = info[0];
        platform_version.version = info[1];
      }
    }
    return platform_version;
};
```
Native 对于 H5 来说有个 Webview 容器，框架&&底层不太关心 H5 的业务实现，所以真实业务中 Native 调用 H5 场景较少。

上面的网络访问 Native 代码（iOS为例）

```
typedef NS_ENUM(NSInteger){
    Hybrid_Request_Method_Post = 0,
    Hybrid_Request_Method_Get = 1
} Hybrid_Request_Method;

@interface RequestModel : NSObject

@property (nonatomic, strong) NSString *url;
@property (nonatomic, assign) Hybrid_Request_Method Hybrid_Request_Method;
@property (nonatomic, strong) NSDictionary *params;

@end


@interface HybridRequest : NSObject


+ (void)requestWithNative:(RequestModel *)requestModel hybridRequestSuccess:(void (^)(id responseObject))success hybridRequestfail:(void (^)(void))fail;

+ (void)requestWithNative:(RequestModel *)requestModel hybridRequestSuccess:(void (^)(id responseObject))success hybridRequestfail:(void (^)(void))fail{
    //处理请求不全的情况
    NSAssert(requestModel || success || fail, @"Something goes wrong");
    
    NSString *url = requestModel.url;
    NSDictionary *params = requestModel.params;
    if (requestModel.Hybrid_Request_Method == Hybrid_Request_Method_Get) {
        [AFNetPackage getJSONWithUrl:url parameters:params success:^(id responseObject) {
            success(responseObject);
        } fail:^{
            fail();
        }];
    }
    else if (requestModel.Hybrid_Request_Method == Hybrid_Request_Method_Post) {
        [AFNetPackage postJSONWithUrl:url parameters:params success:^(id responseObject) {
            success(responseObject);
        } fail:^{
            fail();
        }];
    }
}

```

## 常用交互 Api

良好的交互设计是第一步，在真实业务开发中有一些 Api 一定会由应用场景。

### 跳转
跳转是 Hybrid 必用的 Api 之一，对前端来说有以下情况：
 - 页面内跳转，与 Hybrid 无关
 - H5 跳转 Native 界面
 - H5 新开 Webview 跳转 H5 页面，一般动画切换页面
 如果使用动画，按照业务来说分为前进、后退。forward & backword，规定如下，首先是 H5 跳 Native 某个页面

 ```
 //H5跳Native页面
 //=>SDGHybrid://forward?t=1446297487682&param=%7B%22topage%22%3A%22home%22%2C%22type%22%3A%22h2n%22%2C%22data2%22%3A2%7D
 requestHybrid({
    tagname: 'forward',
    param: {
      // 要去到的页面
      topage: 'home',
      // 跳转方式，H5跳Native
      type: 'native',
      // 其它参数
      data2: 2
    }
 });
 ```

H5 页面要去 Native 某个页面

```
//=>SDGHybrid://forward?t=1446297653344&param=%7B%22topage%22%253A%22Goods%252Fdetail%20%20%22%252C%22type%22%253A%22h2n%22%252C%22id%22%253A20151031%7D
requestHybrid({
  tagname: 'forward',
  param: {
    // 要去到的页面
    topage: 'Goods/detail',
    // 跳转方式，H5跳Native
    type: 'native',
    // 其它参数
    id: 20151031
  }
});
```

H5 新开 Webview 的方式去跳转 H5

```
requestHybrid({
  tagname: 'forward',
  param: {
    // 要去到的页面，首先找到goods频道，然后定位到detail模块
    topage: 'goods/detail  ',
    //跳转方式，H5新开Webview跳转，最后装载H5页面
    type: 'webview',
    //其它参数
    id: 20151031
  }
});
```

back 与 forward 一致，可能会有 animatetype 参数决定页面切换的时候的动画效果。真实使用的时候可能会全局封装方法去忽略 tagname 细节。

## Header 组件的设计
